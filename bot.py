from difflib import SequenceMatcher # Библиотека питона на которой производится сравнение сообщений для ответов
from pyrogram import Client, filters # Сама библиотека подключения к ТГ
from pyrogram.errors import FloodWait # Я пока не понял НАХУЯ, поскольку скописовал готовый код и от части его модифицировал, а это присутствовало там
print('Robot dolboeb v 0.0.1 alpha') # А как иначе назвать???
app = Client("my_account") # sysdeppord_account - для основного акка
answer_list = [] # Создаю блядский список
db = open('answer_databse.bin', 'r') # Открывает БД ответов и получанм дескриптор
print('Файл ответов открыт!')
while True: #Блядский цикл для считывания строк с файла бд и формирования 2Д списка
    line = db.readline() # Считываю блядскую строку с блядского файла БД
    if not line: # Прерываю цикл(не менструации), если строка пустая
            break
    line_of_db = line.split('\\') # Формирую список основываясь на разделителях строки
    answer_list.append(line.split('\\')) # Формирую 2х мерный список на основании списка с разбитой строки (я встроил тебе спимок в список, чтобы ты мог смотреть список пока смотришь список (с)xZibit)
db.close # Закрываю файл для экономии памяти (пока ХЗ почему, зачем, а главное нахуя)
db_strings = len(answer_list) # Подсчёт строк в файле БД для работы последующего перебора сообщений на сравнение. Не удалять, ибо пошлёт "НАХУЙ" после текстового сообщения
print('Строк ответов в базе: ' + str(len(answer_list))) # Дабы порадовать своё ЭГО, или чтобы задизморалить тупостью и так тупого бота
@app.on_message(filters.media) # & filters.private) - для себя, ибо тестирую ещё и на основном акке, на в груповые чаты я ебал его пускать, все охуеют
def media_error(client, message): # Говорит что бот недоразвитый и может работать только с текстом :/
    print("Опять пришла шляпа c медиафайлом от: %s , но я его послал)))" % (message.from_user.username))
    message.reply_text("Я пока умею работать только с ТЕКСТОВЫМИ сообщениями! Всякую медиа-шляпу не воспринимаю!") # Само послание собеседника "НАХУЙ"
    print("Собеседник послан)")
'''
Прикручиваю простой автоответчик.
Посмотрим что выйдет...
UPD 19.12.2021: Ищет первое попавшееся по критерию сравнения в базе сообщение и все последующие пропускает.
'''
@app.on_message(filters.text) # & filters.private)
def text_message(client, message): #Попытка прикрутить автоответчик...
    print('Пользователь %s написал: "%s"' % (message.from_user.username, message.text))
    msg = message.text
    i = 0 # Задаю начальное значение переменной для цикла перебирания ответов в списке считаного с БД
    while i < db_strings: # Сам блядский цикл перебора ответов. Я как fullNOOB проебался с ним 5 часов, но оно того стоило. Буква - "Ю"
        answer = answer_list[i][0] # Переименовываю переменную списка чтобы скормить в сравниватель сообщения
        sm = SequenceMatcher(a=msg, b=answer) # Сравнивает сообщения собеседника с элементами списка БД методом перебора
        if sm.ratio() > 0.55: # Коэффициен сравнения сообщения, чем меньше - тем тупее (хотя бот и так тупее некуда)
            message.reply_text(answer_list[i][1]) # Если ответ подходит под коэффициет сравнения то вытягивает подходящий мне ответ из 2Д списка и отправляет собеседнику
            break # Прерывает блядский цикл при успешном сравнении и отправке сообщения
        else: # Но если ответ не попал под коэффициент похожести то заставляет перебирать строки дальше
            i = i+1 # Переходи на строчку списка вниз
    if i == db_strings: # Но если каким-то блядским образом с таким тупым коэффициентом он не нашел вообще ответа в БД - бот признается в тупости
        message.reply_text('Я пока не могу ответить на такое сообщение') # Само признание в тупости
    print("ответ отправлен") # Просто для лога в консоль
    log = open("message.log", "a") # А это сам лог в файл текста сообщений
    with open('message.log', 'a') as file: # А это запихивает всё сообщения в лог файл
        file.write(message.from_user.username + " написал:\n" + message.text + "\n") # Думаю обьяснять не нужно
############
app.run()
