import random
from difflib import SequenceMatcher # Библиотека питона на которой производится сравнение сообщений для ответов
from pyrogram import Client, filters # Сама библиотека подключения к ТГ
from pyrogram.errors import FloodWait # Я пока не понял НАХУЯ, поскольку скописовал готовый код и от части его модифицировал, а это присутствовало там
print('Robot dolboeb v 0.0.3 alpha') # А как иначе назвать???
app = Client("sysdeppord_account") # sysdeppord_account - для основного акка
answer_list = [] # Создаю блядский список
answr_ls = [] # Список для ответов подходящих по коэффициенту сравнения
db = open('answer_databse.bin', 'r') # Открывает БД ответов и получанм дескриптор
print('Файл ответов открыт!')
while True: #Блядский цикл для считывания строк с файла бд и формирования 2Д списка
    line = db.readline() # Считываю блядскую строку с блядского файла БД
    if not line: # Прерываю цикл(не менструации), если строка пустая
        break
    line_of_db = line.split('\\') # Формирую список основываясь на разделителях строки
    answer_list.append(line.split('\\')) # Формирую 2х мерный список на основании списка с разбитой строки (я встроил тебе спимок в список, чтобы ты мог смотреть список пока смотришь список (с)xZibit)
db.close # Закрываю файл для экономии памяти (пока ХЗ почему, зачем, а главное нахуя)
db_strings = len(answer_list) # Подсчёт строк в файле БД для работы последующего перебора сообщений на сравнение. Не удалять, ибо пошлёт "НАХУЙ" после текстового сообщения
print('Строк ответов в базе: ' + str(len(answer_list))) # Дабы порадовать своё ЭГО, или чтобы задизморалить тупостью и так тупого бота
@app.on_message(filters.media & filters.private) - для себя, ибо тестирую ещё и на основном акке, на в груповые чаты я ебал его пускать, все охуеют
def media_error(client, message): # Говорит что бот недоразвитый и может работать только с текстом :/
    print("Опять пришла шляпа c медиафайлом от: %s , но я его послал)))" % (message.from_user.username))
    message.reply_text("Я пока умею работать только с ТЕКСТОВЫМИ сообщениями! Всякую медиа-шляпу не воспринимаю!") # Само послание собеседника "НАХУЙ"
    print("Собеседник послан)")
'''
Прикручиваю простой автоответчик.
Посмотрим что выйдет...
UPD 19.12.2021: Ищет первое попавшееся по критерию сравнения в базе сообщение и все последующие пропускает.
UPD 22.12.2021: Ну я сделяль чтобы отправлял не первый попавшийся ответ, а чтобы строил список с подходящих ответов, а потом на базе списка случайно выбирал ответ и отправлял собеседнику...
'''
@app.on_message(filters.text & filters.private)
def text_message(client, message): #Попытка прикрутить автоответчик...
    print('Пользователь %s написал: "%s"' % (message.from_user.username, message.text))
    msg = message.text
    i = 0 # Задаю начальное значение переменной для цикла перебирания ответов в списке считаного с БД
    ratio = 0.65 # Задаю коэффициент сравнения
    while i < db_strings+1: # Сам блядский цикл перебора ответов. Я как fullNOOB проебался с ним 5 часов, но оно того стоило. Буква - "Ю"
        answer = answer_list[i][0] # Переименовываю переменную списка чтобы скормить в сравниватель сообщения
        sm = SequenceMatcher(a=msg, b=answer) # Сравнивает сообщения собеседника с элементами списка БД методом перебора
        if sm.ratio() > ratio: # Коэффициен сравнения сообщения, чем меньше - тем тупее (хотя бот и так тупее некуда)
            answr_ls.append(answer_list[i][1]) # Добавляю подходящий ответ из базы в список для рандома
            i = i+1
        else: # Но если ответ не попал под коэффициент похожести то заставляет перебирать строки дальше
            i = i+1 # Переходи на строчку списка вниз
            if i == db_strings: # Но если каким-то блядским образом с таким тупым коэффициентом он не нашел вообще ответа в БД - бот понижает коэффициент
                break
    rep_id = random.randint(0, len(answr_ls))-1 # Присваиваю функции рандома с нужными значениями переменную
    if len(answr_ls) == 0: # Если ответа так и не было найдено
        message.reply_text('Я пока не могу найти ответ на это сообщение, но в будущем обязательно буду знать!')
        print("Неизвестное сообщение добавлено в файл!\n") # Просто для лога в консоль
        with open('unknow_answer.list', 'a') as file: # А это запихивает неизвестное сообщение в файл для, как ни странно, неизвестных сообщений
            file.write(message.text + "\n") # Добавляем неизвестный вопрос в базу
        with open('message.log', 'a') as file: # А это запихивает всё сообщения в лог файл
            file.write(message.from_user.username + " написал:\n" + message.text + "\nНеопознаное сообщение записано в файл неизвестных сообщений\n\n") # Думаю обьяснять не нужно
        answr_ls.clear() # На всякий случай очищаем список сообщений для рандома
    else: # Если есть хоть какое то совпадение
        message.reply_text(answr_ls[rep_id]) # Отправляем подготовленный тест с сообщением
        print("Ответ отправлен: \n" + answr_ls[rep_id] + '\n') # Просто для лога в консоль
        with open('message.log', 'a') as file: # А это запихивает всё сообщения в лог файл
            file.write(message.from_user.username + " написал:\n" + message.text + "\nОтвет отправлен: \n" + answr_ls[rep_id] + "\n\n") # Думаю обьяснять не нужно
        answr_ls.clear() # Очищаем список сообщений для рандома, дабы следующее сообщение было со своим
answr_ls.clear() # Перестраховываемся со списком сообщений для рандома
############
app.run()
